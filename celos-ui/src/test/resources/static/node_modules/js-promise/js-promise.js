/**
 * Created by Ramy Eldesoky on 6/13/2014.
 */

"use strict";

var Promise = Promise || (function(){
	var states = {
		pending: 0,
		success: 1,
		failed: 2,
		cancelled: 3
	};

	function CPromise( init ) {
		this._callbacklist = [];
		this._state = states.pending;

		if(init){
			init(this.resolve.bind(this), this.reject.bind(this));
		}
	}

	var noSuccessHandler = function(result){
		console.error( "Default js-promise Success Handler." + ( (result !== undefined ) ? " result=" + JSON.stringify(result) : "" ) );
		return result;
	};
	var noErrorHandler = function(err){
		console.error( "Default js-promise Error Handler." + ( (err !== undefined ) ? " error=" + JSON.stringify(err) : "" ) );
		return err;
	};

	CPromise.prototype = {
		then: function (onSuccess, onFailure) {
			var thenPromise = new CPromise();//then of
			this._callbacklist.push({
				onSuccess: onSuccess||noSuccessHandler,
				onFailure: onFailure||noErrorHandler,
				thenPromise: thenPromise
			});
			this._notifyListeners();
			return thenPromise;
		},
		done: function (onSuccess, onFailure) {
			this._callbacklist.push({
				onSuccess: onSuccess||noSuccessHandler,
				onFailure: onFailure||noErrorHandler
			});
			this._notifyListeners();
			// doesn't return a new promise
		},
		_notifyListeners: function () {// notify onSuccess callbacks if promise is resolved
			if(CPromise.is(this._value)){
				return;//wait for new promise to be resolved
			}

			if( this._state == states.success || this._state == states.failed ){
				while( this._callbacklist.length ){
					var cb = this._callbacklist[0];
					this._callbacklist.splice(0, 1);//remove the callback node

					var then_ret = (this._state == states.success) ?
						cb.onSuccess(this._value) :
						cb.onFailure(this._value) ;

					if (cb.thenPromise) {
						//chain to returned promise
						(this._state == states.success)?
							cb.thenPromise.resolve(then_ret):
							cb.thenPromise.reject(then_ret);
					}
				}
			}
		},
		cancel:function(){
			this._state = states.cancelled;
			this._callbacklist.length = 0;
			return this;
		},
		reject:function(err_val){
			this._value = err_val;
			this._state = states.failed;
			this._notifyListeners();
			return this;
		},
		resolve: function (val) {
			if(this._state == states.success){
				return this;// already resolved
			}
			if( CPromise.is( val ) ) {
				//if value is a promise, wait for the resolve
				val.done(this.resolve.bind(this), this.reject.bind(this));
				return this;
			}
			this._state = states.success;
			this._value = val;
			this._notifyListeners();
			return this;
		}
	};

	CPromise.prototype.fulfill = CPromise.prototype.resolve;

	CPromise.wrap = CPromise.resolve = CPromise.as = function(val){
		return CPromise.is(val) ? val : (new CPromise()).resolve(val);
	};

	CPromise.is = function(val){
		//return( val && (val.constructor == CPromise) );
		return( (val !== null) && (val !== undefined) && (typeof val.then === "function") && (typeof val.done === "function") );
	};

	CPromise.wrapError = CPromise.reject = CPromise.error = function(err){
		return new CPromise(function(onSuccess,onError){
			onError(err);
		});
	};

	CPromise.any = CPromise.race = function(list){
		var ret = new CPromise();
		var doneHandler = function(){
			ret.resolve();
		};
		list.forEach(function(pr){
			pr.done(doneHandler, doneHandler);
		});
		return ret;
	};

	return CPromise

})();
